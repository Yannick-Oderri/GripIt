# generated from devel/devel_task.Dockerfile.em

FROM ubuntu:xenial

VOLUME ["/var/cache/apt/archives"]

ENV DEBIAN_FRONTEND noninteractive


RUN for i in 1 2 3; do apt-get update && apt-get install -q -y locales && apt-get clean && break || if [[ $i < 3 ]]; then sleep 5; else false; fi; done
RUN echo "en_US.UTF-8 UTF-8" >> /etc/locale.gen
RUN locale-gen en_US.UTF-8
ENV LANG en_US.UTF-8
ENV TZ EST+05

RUN useradd -u 1000 -m buildfarm

RUN mkdir /tmp/keys
RUN echo "-----BEGIN PGP PUBLIC KEY BLOCK-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\nmQGiBEsy5KkRBADJbDSISoamRM5AA20bfAeBuhhaI+VaiCVcxw90sq9AI5lIc42F\nWzM2acm8yplqWiehAqOLKd+iIrqNGZ+VavZEPTx7o06UZUMRoPBiTFaCwrQ5avKz\nlt7ij8PRMVWNrJ7A2lDYXfFQVV1o3Xo06qVnv0KLLUmiur0LBu4H/oTH3wCgt+/I\nD3LUKaMJsc77KwFBTjHB0EsD/26Z2Ud12f3urSNyN6VMWnP3rz6xsmtY4Qsmkbnr\nJuduxCQBZv6bX1Cr2ulXkv0fFOr+s5OyUv7zyCPbxiJFh3Br7fJGb0b5/M208KPe\ngiITY9hMh/aUbKjXCPoOXPxSL6SWOWV8taR6903EFyLBN0qno/kXIBKnVqBZobgn\njIEPA/0fTnxtZtE7EpirGQMF2caJfv7/LCgXmRs9xAhgbE0/caoa1tnc79uaHmLZ\nFtbGFoAO31YNYM/IUHtmabbGdvZ4oYUwDhjBevVvC7aI+XhuNGK5mU8qCLLSEUOl\nCUr6BJq/0iFmjwjmwk9idZEYhqSNy2OoYJbq45rbHfbdKLEVrbQeUk9TIEJ1aWxk\nZXIgPHJvc2J1aWxkQHJvcy5vcmc+iGAEExECACAFAksy5KkCGwMGCwkIBwMCBBUC\nCAMEFgIDAQIeAQIXgAAKCRBVI7rusB+hFmk7AJ0XsLp05KA8l3YzAumZfjSN04MZ\njQCfQHfp4aQUXdOCUtetVo0QZUX3IuO5Ag0ESzLkrhAIAOCuSC83VXYWf8gOMSzd\nxwpsH/uLV9Wze2LGnajsJLjEOhcsz2BHfxqNXhYaE9aQaodPCpbUAkPq8tLbpXy0\nSWRCx0F5RcplXx5vIWbP6TlfPbRpK70w7IWd6vsNrjwEHjlhOLcNcj42sp5pgx4b\ndceK06k5Ml2hYovPnD9o2TYgjOqg5FHZ2g1J0103n/66bN/hZnpLaZJYQiPWCyq6\nK0565i1k2Y7hgWB/OXqwaqCehqmLTvpyQGzE1UJvKLuYU+T+4hBnSPbT3KIi5fCz\nlIwvxijOMcfbkLhzYQXcU0Rd1VItcd5nmPL4z97jBxzuhkgxXpGR4WGKhvsA2Z9Y\nUtsAAwYH/3Bf44bTpD9bVADUdab3e7zm8iHfh9K/a83mIgDB7mHV6WuemQVTf/1d\neu4mI5WtpbOCoucybGfjGIIAcSxwIx6VfC7HSp4J51bOpHhbdDffUEk6QVsZjwoF\nyn3W9W3ZVeTI+ch/Qoo5a98SnmdjN8eXI/qCuiXOHc6rXDXc2R0iox/1EAS8xGVd\ncYZe7IWBO2CjCknyhLrWxZHoy+i1GCZ9KvPF/Ef2dmLhCydT73ZlumsY8N5vm76Q\nul1G7f8LNbnMgXQafRkPffrAXSVhGY3Z2IiBwFNgxcKTq479l7yedYRGeU1A+SYI\nYmRFWHXt3rTkMlQSpxCsB0fAYfrwEqqISQQYEQIACQUCSzLkrgIbDAAKCRBVI7ru\nsB+hFpryAJ4puo6cMZxa6wITHFAM/k84+aRijwCeItuWpUngP25xDuDGMsKarcNi\nqYE=\n=Vgio\n-----END PGP PUBLIC KEY BLOCK-----\n" > /tmp/keys/0.key && apt-key add /tmp/keys/0.key
RUN echo deb http://repositories.ros.org/ubuntu/testing xenial main | tee -a /etc/apt/sources.list.d/buildfarm.list

RUN grep -q -F -e "deb http://old-releases.ubuntu.com" /etc/apt/sources.list && ((grep -q -E -x -e "deb http://old-releases\.ubuntu\.com/ubuntu/? xenial ([-a-z]+ )*multiverse( [-a-z]+)*" /etc/apt/sources.list || echo "deb http://old-releases.ubuntu.com/ubuntu/ xenial multiverse" >> /etc/apt/sources.list) && (grep -q -E -x -e "deb-src http://old-releases\.ubuntu\.com/ubuntu/? xenial ([-a-z]+ )*multiverse( [-a-z]+)*" /etc/apt/sources.list || echo "deb-src http://old-releases.ubuntu.com/ubuntu/ xenial multiverse" >> /etc/apt/sources.list) && (grep -q -E -x -e "deb http://old-releases\.ubuntu\.com/ubuntu/? xenial-updates ([-a-z]+ )*multiverse( [-a-z]+)*" /etc/apt/sources.list || echo "deb http://old-releases.ubuntu.com/ubuntu/ xenial-updates multiverse" >> /etc/apt/sources.list) && (grep -q -E -x -e "deb-src http://old-releases\.ubuntu\.com/ubuntu/? xenial-updates ([-a-z]+ )*multiverse( [-a-z]+)*" /etc/apt/sources.list || echo "deb-src http://old-releases.ubuntu.com/ubuntu/ xenial-updates multiverse" >> /etc/apt/sources.list) && (grep -q -E -x -e "deb http://old-releases\.ubuntu\.com/ubuntu/? xenial-security ([-a-z]+ )*multiverse( [-a-z]+)*" /etc/apt/sources.list || echo "deb http://old-releases.ubuntu.com/ubuntu/ xenial-security multiverse" >> /etc/apt/sources.list) && (grep -q -E -x -e "deb-src http://old-releases\.ubuntu\.com/ubuntu/? xenial-security ([-a-z]+ )*multiverse( [-a-z]+)*" /etc/apt/sources.list || echo "deb-src http://old-releases.ubuntu.com/ubuntu/ xenial-security multiverse" >> /etc/apt/sources.list)) || ((grep -q -E -x -e "deb http://archive\.ubuntu\.com/ubuntu/? xenial ([-a-z]+ )*multiverse( [-a-z])*" /etc/apt/sources.list || echo "deb http://archive.ubuntu.com/ubuntu/ xenial multiverse" >> /etc/apt/sources.list) && (grep -q -E -x -e "deb-src http://archive\.ubuntu\.com/ubuntu/? xenial ([-a-z]+ )*multiverse( [-a-z])*" /etc/apt/sources.list || echo "deb-src http://archive.ubuntu.com/ubuntu/ xenial multiverse" >> /etc/apt/sources.list) && (grep -q -E -x -e "deb http://archive\.ubuntu\.com/ubuntu/? xenial-updates ([-a-z]+ )*multiverse( [-a-z])*" /etc/apt/sources.list || echo "deb http://archive.ubuntu.com/ubuntu/ xenial-updates multiverse" >> /etc/apt/sources.list) && (grep -q -E -x -e "deb-src http://archive\.ubuntu\.com/ubuntu/? xenial-updates ([-a-z]+ )*multiverse( [-a-z])*" /etc/apt/sources.list || echo "deb-src http://archive.ubuntu.com/ubuntu/ xenial-updates multiverse" >> /etc/apt/sources.list) && (grep -q -E -x -e "deb http://archive\.ubuntu\.com/ubuntu/? xenial-security ([-a-z]+ )*multiverse( [-a-z])*" /etc/apt/sources.list || echo "deb http://archive.ubuntu.com/ubuntu/ xenial-security multiverse" >> /etc/apt/sources.list) && (grep -q -E -x -e "deb-src http://archive\.ubuntu\.com/ubuntu/? xenial-security ([-a-z]+ )*multiverse( [-a-z])*" /etc/apt/sources.list || echo "deb-src http://archive.ubuntu.com/ubuntu/ xenial-security multiverse" >> /etc/apt/sources.list))

RUN mkdir /tmp/wrapper_scripts
RUN echo "#!/usr/bin/env python3\n\n# Copyright 2014-2016 Open Source Robotics Foundation, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport subprocess\nimport sys\nfrom time import sleep\n\n\ndef main(argv=sys.argv[1:]):\n    max_tries = 10\n    known_error_strings = [\n        'Failed to fetch',\n        'Failed to stat',\n        'Hash Sum mismatch',\n        'Unable to locate package',\n        'is not what the server reported',\n    ]\n\n    command = argv[0]\n    if command in ['update', 'source']:\n        rc, _, _ = call_apt_repeatedly(\n            argv, known_error_strings, max_tries)\n        return rc\n    elif command == 'update-install-clean':\n        return call_apt_update_install_clean(\n            argv[1:], known_error_strings, max_tries)\n    else:\n        assert \"Command '%s' not implemented\" % command\n\n\ndef call_apt_update_install_clean(\n        install_argv, known_error_strings, max_tries):\n    tries = 0\n    command = 'update'\n    while tries < max_tries:\n        if command == 'update':\n            rc, _, tries = call_apt_repeatedly(\n                [command], known_error_strings, max_tries - tries,\n                offset=tries)\n            if rc != 0:\n                # abort if update was unsuccessful even after retries\n                break\n            # move on to the install command if update was successful\n            command = 'install'\n\n        if command == 'install':\n            # any call is considered a try\n            tries += 1\n            known_error_strings_redo_update = [\n                'Size mismatch',\n                'maybe run apt update',\n                'The following packages cannot be authenticated!',\n                'Unable to locate package',\n                'has no installation candidate',\n                'corrupted package archive',\n            ]\n            rc, known_error_conditions = \\\\\n                call_apt(\n                    [command] + install_argv,\n                    known_error_strings + known_error_strings_redo_update)\n            if not known_error_conditions:\n                if rc != 0:\n                    # abort if install was unsuccessful\n                    break\n                # move on to the clean command if install was successful\n                command = 'clean'\n                continue\n\n            # known errors are always interpreted as a non-zero rc\n            if rc == 0:\n                rc = 1\n            # check if update needs to be rerun\n            if (\n                set(known_error_conditions) &\n                set(known_error_strings_redo_update)\n            ):\n                command = 'update'\n                print(\"'apt install' failed and likely requires \" +\n                      \"'apt update' to run again\")\n                # retry with update command\n                continue\n\n            print('')\n            print('Invocation failed due to the following known error '\n                  'conditions: ' + ', '.join(known_error_conditions))\n            print('')\n            if tries < max_tries:\n                sleep_time = 5\n                print(\"Reinvoke 'apt install' after sleeping %s seconds\" %\n                      sleep_time)\n                sleep(sleep_time)\n                # retry install command\n\n        if command == 'clean':\n            rc, _ = call_apt([command], [])\n            break\n\n    return rc\n\n\ndef call_apt_repeatedly(argv, known_error_strings, max_tries, offset=0):\n    command = argv[0]\n    for i in range(1, max_tries + 1):\n        if i > 1:\n            sleep_time = 5 + 2 * (i + offset)\n            print(\"Reinvoke 'apt %s' (%d/%d) after sleeping %s seconds\" %\n                  (command, i + offset, max_tries + offset, sleep_time))\n            sleep(sleep_time)\n        rc, known_error_conditions = call_apt(argv, known_error_strings)\n        if not known_error_conditions:\n            # break the loop and return the reported rc\n            break\n        # known errors are always interpreted as a non-zero rc\n        if rc == 0:\n            rc = 1\n        print('')\n        print('Invocation failed due to the following known error conditions: '\n              ', '.join(known_error_conditions))\n        print('')\n        # retry in case of failure with known error condition\n    return rc, known_error_conditions, i + offset\n\n\ndef call_apt(argv, known_error_strings):\n    known_error_conditions = []\n\n    # some of the used options are not supported in older distros\n    # e.g. Ubuntu Wily, Debian Jessie\n    cmd = ['apt-get'] + argv\n    print(\"Invoking '%s'\" % ' '.join(cmd))\n    proc = subprocess.Popen(\n        cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    lines = []\n    while True:\n        line = proc.stdout.readline()\n        if not line:\n            break\n        line = line.decode()\n        lines.append(line)\n        sys.stdout.write(line)\n        for known_error_string in known_error_strings:\n            if known_error_string in line:\n                if known_error_string not in known_error_conditions:\n                    known_error_conditions.append(known_error_string)\n    proc.wait()\n    rc = proc.returncode\n    if rc and not known_error_conditions:\n        print('Invocation failed without any known error condition, '\n              'printing all lines to debug known error detection:')\n        for index, line in enumerate(lines):\n            print(' ', index + 1, \"'%s'\" % line.rstrip('\\\\n\\\\r'))\n        print('None of the following known errors were detected:')\n        for index, known_error_string in enumerate(known_error_strings):\n            print(' ', index + 1, \"'%s'\" % known_error_string)\n    return rc, known_error_conditions\n\n\nif __name__ == '__main__':\n    sys.exit(main())" > /tmp/wrapper_scripts/apt.py
RUN echo "#!/usr/bin/env python3\n\n# Copyright 2016 Open Source Robotics Foundation, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport subprocess\nimport sys\nfrom time import sleep\n\n\ndef main(argv=sys.argv[1:]):\n    max_tries = 10\n    known_error_strings = [\n        'Connection timed out',\n    ]\n\n    command = argv[0]\n    if command == 'clone':\n        rc, _, _ = call_git_repeatedly(\n            argv, known_error_strings, max_tries)\n        return rc\n    else:\n        assert \"Command '%s' not implemented\" % command\n\n\ndef call_git_repeatedly(argv, known_error_strings, max_tries):\n    command = argv[0]\n    for i in range(1, max_tries + 1):\n        if i > 1:\n            sleep_time = 5 + 2 * i\n            print(\"Reinvoke 'git %s' (%d/%d) after sleeping %s seconds\" %\n                  (command, i, max_tries, sleep_time))\n            sleep(sleep_time)\n        rc, known_error_conditions = call_git(argv, known_error_strings)\n        if rc == 0 or not known_error_conditions:\n            break\n        print('')\n        print('Invocation failed due to the following known error conditions: '\n              ', '.join(known_error_conditions))\n        print('')\n        # retry in case of failure with known error condition\n    return rc, known_error_conditions, i\n\n\ndef call_git(argv, known_error_strings):\n    known_error_conditions = []\n\n    cmd = ['git'] + argv\n    print(\"Invoking '%s'\" % ' '.join(cmd))\n    proc = subprocess.Popen(\n        cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    while True:\n        line = proc.stdout.readline()\n        if not line:\n            break\n        line = line.decode()\n        sys.stdout.write(line)\n        for known_error_string in known_error_strings:\n            if known_error_string in line:\n                if known_error_string not in known_error_conditions:\n                    known_error_conditions.append(known_error_string)\n    proc.wait()\n    rc = proc.returncode\n    return rc, known_error_conditions\n\n\nif __name__ == '__main__':\n    sys.exit(main())" > /tmp/wrapper_scripts/git.py

# automatic invalidation once every day
RUN echo "2019-01-22 (-0500)"

RUN for i in 1 2 3; do apt-get update && apt-get install -q -y python3 && apt-get clean && break || if [[ $i < 3 ]]; then sleep 5; else false; fi; done

RUN python3 -u /tmp/wrapper_scripts/apt.py update-install-clean -q -y ccache

# for each dependency: echo version, apt update, apt install, apt clean
# to prevent exceeding the docker layer limit several lines have been folded
RUN echo "build-essential: 12.1ubuntu2" && echo "python3: 3.5.1-3" && echo "ros-kinetic-catkin: 0.7.14-0xenial-20180809-132632-0800" && echo "python-future: 0.15.2-1" && echo "python-numpy: 1:1.11.0-1ubuntu1" && echo "python-skimage: 0.10.1-2build1" && echo "ros-kinetic-rospy: 1.12.14-0xenial-20180824-093546-0800" && echo "pyqt5-dev-tools: 5.5.1+dfsg-3ubuntu4" && echo "python-rosdep: 0.14.0-1" && python3 -u /tmp/wrapper_scripts/apt.py update-install-clean -q -y -o Debug::pkgProblemResolver=yes build-essential python3 ros-kinetic-catkin python-future python-numpy python-skimage ros-kinetic-rospy pyqt5-dev-tools python-rosdep

USER buildfarm
ENTRYPOINT ["sh", "-c"]
CMD ["PATH=/usr/lib/ccache:$PATH PYTHONPATH=/tmp/ros_buildfarm:$PYTHONPATH python3 -u /tmp/ros_buildfarm/scripts/devel/catkin_make_isolated_and_test.py --rosdistro-name kinetic --workspace-root /tmp/catkin_workspace"]
